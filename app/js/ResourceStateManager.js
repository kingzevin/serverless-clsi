//@ sourceMappingURL=ResourceStateManager.map
// Generated by CoffeeScript 1.6.0
(function() {
  var Errors, Path, ResourceStateManager, SafeReader, fs, logger, settings,
    __slice = [].slice;

  Path = require("path");

  fs = require("fs");

  logger = require("logger-sharelatex");

  settings = require("settings-sharelatex");

  Errors = require("./Errors");

  SafeReader = require("./SafeReader");

  module.exports = ResourceStateManager = {
    SYNC_STATE_FILE: ".project-sync-state",
    SYNC_STATE_MAX_SIZE: 128 * 1024,
    saveProjectState: function(state, resources, basePath, callback) {
      var resource, resourceList, stateFile;
      if (callback == null) {
        callback = function(error) {};
      }
      stateFile = Path.join(basePath, this.SYNC_STATE_FILE);
      if (state == null) {
        logger.log({
          state: state,
          basePath: basePath
        }, "clearing sync state");
        return fs.unlink(stateFile, function(err) {
          if ((err != null) && err.code !== 'ENOENT') {
            return callback(err);
          } else {
            return callback();
          }
        });
      } else {
        logger.log({
          state: state,
          basePath: basePath
        }, "writing sync state");
        resourceList = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = resources.length; _i < _len; _i++) {
            resource = resources[_i];
            _results.push(resource.path);
          }
          return _results;
        })();
        return fs.writeFile(stateFile, __slice.call(resourceList).concat(["stateHash:" + state]).join("\n"), callback);
      }
    },
    checkProjectStateMatches: function(state, basePath, callback) {
      var size, stateFile;
      if (callback == null) {
        callback = function(error, resources) {};
      }
      stateFile = Path.join(basePath, this.SYNC_STATE_FILE);
      size = this.SYNC_STATE_MAX_SIZE;
      return SafeReader.readFile(stateFile, size, 'utf8', function(err, result, bytesRead) {
        var newState, oldState, path, resourceList, resources, _i, _ref, _ref1;
        if (err != null) {
          return callback(err);
        }
        if (bytesRead === size) {
          logger.error({
            file: stateFile,
            size: size,
            bytesRead: bytesRead
          }, "project state file truncated");
        }
        _ref1 = (result != null ? (_ref = result.toString()) != null ? _ref.split("\n") : void 0 : void 0) || [], resourceList = 2 <= _ref1.length ? __slice.call(_ref1, 0, _i = _ref1.length - 1) : (_i = 0, []), oldState = _ref1[_i++];
        newState = "stateHash:" + state;
        logger.log({
          state: state,
          oldState: oldState,
          basePath: basePath,
          stateMatches: newState === oldState
        }, "checking sync state");
        if (newState !== oldState) {
          return callback(new Errors.FilesOutOfSyncError("invalid state for incremental update"));
        } else {
          resources = (function() {
            var _j, _len, _results;
            _results = [];
            for (_j = 0, _len = resourceList.length; _j < _len; _j++) {
              path = resourceList[_j];
              _results.push({
                path: path
              });
            }
            return _results;
          })();
          return callback(null, resources);
        }
      });
    },
    checkResourceFiles: function(resources, allFiles, basePath, callback) {
      var dir, file, missingFiles, resource, seenFile, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      if (callback == null) {
        callback = function(error) {};
      }
      _ref = resources || [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        file = _ref[_i];
        _ref2 = file != null ? (_ref1 = file.path) != null ? _ref1.split('/') : void 0 : void 0;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          dir = _ref2[_j];
          if (dir === '..') {
            return callback(new Error("relative path in resource file list"));
          }
        }
      }
      seenFile = {};
      for (_k = 0, _len2 = allFiles.length; _k < _len2; _k++) {
        file = allFiles[_k];
        seenFile[file] = true;
      }
      missingFiles = (function() {
        var _l, _len3, _results;
        _results = [];
        for (_l = 0, _len3 = resources.length; _l < _len3; _l++) {
          resource = resources[_l];
          if (!seenFile[resource.path]) {
            _results.push(resource.path);
          }
        }
        return _results;
      })();
      if ((missingFiles != null ? missingFiles.length : void 0) > 0) {
        logger.err({
          missingFiles: missingFiles,
          basePath: basePath,
          allFiles: allFiles,
          resources: resources
        }, "missing input files for project");
        return callback(new Errors.FilesOutOfSyncError("resource files missing in incremental update"));
      } else {
        return callback();
      }
    }
  };

}).call(this);
