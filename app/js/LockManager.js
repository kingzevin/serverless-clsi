//@ sourceMappingURL=LockManager.map
// Generated by CoffeeScript 1.6.0
(function() {
  var Errors, LockManager, Lockfile, Path, Settings, fs, logger,
    __slice = [].slice;

  Settings = require('settings-sharelatex');

  logger = require("logger-sharelatex");

  Lockfile = require('lockfile');

  Errors = require("./Errors");

  fs = require("fs");

  Path = require("path");

  module.exports = LockManager = {
    LOCK_TEST_INTERVAL: 1000,
    MAX_LOCK_WAIT_TIME: 15000,
    LOCK_STALE: 5 * 60 * 1000,
    runWithLock: function(path, runner, callback) {
      var lockOpts;
      if (runner == null) {
        runner = (function(releaseLock) {
          if (releaseLock == null) {
            releaseLock = function(error) {};
          }
        });
      }
      if (callback == null) {
        callback = (function(error) {});
      }
      lockOpts = {
        wait: this.MAX_LOCK_WAIT_TIME,
        pollPeriod: this.LOCK_TEST_INTERVAL,
        stale: this.LOCK_STALE
      };
      return Lockfile.lock(path, lockOpts, function(error) {
        if ((error != null ? error.code : void 0) === 'EEXIST') {
          return callback(new Errors.AlreadyCompilingError("compile in progress"));
        } else if (error != null) {
          return fs.lstat(path, function(statLockErr, statLock) {
            return fs.lstat(Path.dirname(path), function(statDirErr, statDir) {
              return fs.readdir(Path.dirname(path), function(readdirErr, readdirDir) {
                logger.err({
                  error: error,
                  path: path,
                  statLock: statLock,
                  statLockErr: statLockErr,
                  statDir: statDir,
                  statDirErr: statDirErr,
                  readdirErr: readdirErr,
                  readdirDir: readdirDir
                }, "unable to get lock");
                return callback(error);
              });
            });
          });
        } else {
          return runner(function() {
            var args, error1;
            error1 = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
            return Lockfile.unlock(path, function(error2) {
              error = error1 || error2;
              if (error != null) {
                return callback(error);
              }
              return callback.apply(null, [null].concat(__slice.call(args)));
            });
          });
        }
      });
    }
  };

}).call(this);
