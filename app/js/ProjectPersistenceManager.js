//@ sourceMappingURL=ProjectPersistenceManager.map
// Generated by CoffeeScript 1.6.0
(function() {
  var CompileManager, ProjectPersistenceManager, Settings, UrlCache, async, db, dbQueue, logger, oneDay;

  UrlCache = require("./UrlCache");

  CompileManager = require("./CompileManager");

  db = require("./db");

  dbQueue = require("./DbQueue");

  async = require("async");

  logger = require("logger-sharelatex");

  oneDay = 24 * 60 * 60 * 1000;

  Settings = require("settings-sharelatex");

  module.exports = ProjectPersistenceManager = {
    EXPIRY_TIMEOUT: Settings.project_cache_length_ms || oneDay * 2.5,
    markProjectAsJustAccessed: function(project_id, callback) {
      var job;
      if (callback == null) {
        callback = function(error) {};
      }
      job = function(cb) {
        return db.Project.findOrCreate({
          where: {
            project_id: project_id
          }
        }).spread(function(project, created) {
          return project.updateAttributes({
            lastAccessed: new Date()
          }).then(function() {
            return cb();
          }).error(cb);
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    },
    clearExpiredProjects: function(callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return ProjectPersistenceManager._findExpiredProjectIds(function(error, project_ids) {
        var jobs, project_id;
        if (error != null) {
          return callback(error);
        }
        logger.log({
          project_ids: project_ids
        }, "clearing expired projects");
        jobs = (function() {
          var _i, _len, _ref, _results;
          _ref = project_ids || [];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            project_id = _ref[_i];
            _results.push((function(project_id) {
              return function(callback) {
                return ProjectPersistenceManager.clearProjectFromCache(project_id, function(err) {
                  if (err != null) {
                    logger.error({
                      err: err,
                      project_id: project_id
                    }, "error clearing project");
                  }
                  return callback();
                });
              };
            })(project_id));
          }
          return _results;
        })();
        return async.series(jobs, function(error) {
          if (error != null) {
            return callback(error);
          }
          return CompileManager.clearExpiredProjects(ProjectPersistenceManager.EXPIRY_TIMEOUT, function(error) {
            return callback();
          });
        });
      });
    },
    clearProject: function(project_id, user_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      logger.log({
        project_id: project_id,
        user_id: user_id
      }, "clearing project for user");
      return CompileManager.clearProject(project_id, user_id, function(error) {
        if (error != null) {
          return callback(error);
        }
        return ProjectPersistenceManager.clearProjectFromCache(project_id, function(error) {
          if (error != null) {
            return callback(error);
          }
          return callback();
        });
      });
    },
    clearProjectFromCache: function(project_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      logger.log({
        project_id: project_id
      }, "clearing project from cache");
      return UrlCache.clearProject(project_id, function(error) {
        if (error != null) {
          logger.err({
            error: error,
            project_id: project_id
          }, "error clearing project from cache");
          return callback(error);
        }
        return ProjectPersistenceManager._clearProjectFromDatabase(project_id, function(error) {
          if (error != null) {
            logger.err({
              error: error,
              project_id: project_id
            }, "error clearing project from database");
          }
          return callback(error);
        });
      });
    },
    _clearProjectFromDatabase: function(project_id, callback) {
      var job;
      if (callback == null) {
        callback = function(error) {};
      }
      logger.log({
        project_id: project_id
      }, "clearing project from database");
      job = function(cb) {
        return db.Project.destroy({
          where: {
            project_id: project_id
          }
        }).then(function() {
          return cb();
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    },
    _findExpiredProjectIds: function(callback) {
      var job;
      if (callback == null) {
        callback = function(error, project_ids) {};
      }
      job = function(cb) {
        var keepProjectsFrom, q;
        keepProjectsFrom = new Date(Date.now() - ProjectPersistenceManager.EXPIRY_TIMEOUT);
        q = {};
        q[db.op.lt] = keepProjectsFrom;
        return db.Project.findAll({
          where: {
            lastAccessed: q
          }
        }).then(function(projects) {
          return cb(null, projects.map(function(project) {
            return project.project_id;
          }));
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    }
  };

  logger.log({
    EXPIRY_TIMEOUT: ProjectPersistenceManager.EXPIRY_TIMEOUT
  }, "project assets kept timeout");

}).call(this);
