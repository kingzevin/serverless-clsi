//@ sourceMappingURL=ResourceWriter.map
// Generated by CoffeeScript 1.6.0
(function() {
  var Metrics, OutputFileFinder, Path, ResourceStateManager, ResourceWriter, UrlCache, async, fs, logger, mkdirp, parallelFileDownloads, settings,
    __slice = [].slice;

  UrlCache = require("./UrlCache");

  Path = require("path");

  fs = require("fs");

  async = require("async");

  mkdirp = require("mkdirp");

  OutputFileFinder = require("./OutputFileFinder");

  ResourceStateManager = require("./ResourceStateManager");

  Metrics = require("./Metrics");

  logger = require("logger-sharelatex");

  settings = require("settings-sharelatex");

  parallelFileDownloads = settings.parallelFileDownloads || 1;

  module.exports = ResourceWriter = {
    syncResourcesToDisk: function(request, basePath, callback) {
      if (callback == null) {
        callback = function(error, resourceList) {};
      }
      if (request.syncType === "incremental") {
        logger.log({
          project_id: request.project_id,
          user_id: request.user_id
        }, "incremental sync");
        return ResourceStateManager.checkProjectStateMatches(request.syncState, basePath, function(error, resourceList) {
          if (error != null) {
            return callback(error);
          }
          return ResourceWriter._removeExtraneousFiles(resourceList, basePath, function(error, outputFiles, allFiles) {
            if (error != null) {
              return callback(error);
            }
            return ResourceStateManager.checkResourceFiles(resourceList, allFiles, basePath, function(error) {
              if (error != null) {
                return callback(error);
              }
              return ResourceWriter.saveIncrementalResourcesToDisk(request.project_id, request.resources, basePath, function(error) {
                if (error != null) {
                  return callback(error);
                }
                return callback(null, resourceList);
              });
            });
          });
        });
      } else {
        logger.log({
          project_id: request.project_id,
          user_id: request.user_id
        }, "full sync");
        return this.saveAllResourcesToDisk(request.project_id, request.resources, basePath, function(error) {
          if (error != null) {
            return callback(error);
          }
          return ResourceStateManager.saveProjectState(request.syncState, request.resources, basePath, function(error) {
            if (error != null) {
              return callback(error);
            }
            return callback(null, request.resources);
          });
        });
      }
    },
    saveIncrementalResourcesToDisk: function(project_id, resources, basePath, callback) {
      var _this = this;
      if (callback == null) {
        callback = function(error) {};
      }
      return this._createDirectory(basePath, function(error) {
        var jobs, resource;
        if (error != null) {
          return callback(error);
        }
        jobs = (function() {
          var _i, _len, _results,
            _this = this;
          _results = [];
          for (_i = 0, _len = resources.length; _i < _len; _i++) {
            resource = resources[_i];
            _results.push((function(resource) {
              return function(callback) {
                return _this._writeResourceToDisk(project_id, resource, basePath, callback);
              };
            })(resource));
          }
          return _results;
        }).call(_this);
        return async.parallelLimit(jobs, parallelFileDownloads, callback);
      });
    },
    saveAllResourcesToDisk: function(project_id, resources, basePath, callback) {
      var _this = this;
      if (callback == null) {
        callback = function(error) {};
      }
      return this._createDirectory(basePath, function(error) {
        if (error != null) {
          return callback(error);
        }
        return _this._removeExtraneousFiles(resources, basePath, function(error) {
          var jobs, resource;
          if (error != null) {
            return callback(error);
          }
          jobs = (function() {
            var _i, _len, _results,
              _this = this;
            _results = [];
            for (_i = 0, _len = resources.length; _i < _len; _i++) {
              resource = resources[_i];
              _results.push((function(resource) {
                return function(callback) {
                  return _this._writeResourceToDisk(project_id, resource, basePath, callback);
                };
              })(resource));
            }
            return _results;
          }).call(_this);
          return async.parallelLimit(jobs, parallelFileDownloads, callback);
        });
      });
    },
    _createDirectory: function(basePath, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return fs.mkdir(basePath, function(err) {
        if (err != null) {
          if (err.code === 'EEXIST') {
            return callback();
          } else {
            logger.log({
              err: err,
              dir: basePath
            }, "error creating directory");
            return callback(err);
          }
        } else {
          return callback();
        }
      });
    },
    _removeExtraneousFiles: function(resources, basePath, _callback) {
      var callback, timer;
      if (_callback == null) {
        _callback = function(error, outputFiles, allFiles) {};
      }
      timer = new Metrics.Timer("unlink-output-files");
      callback = function() {
        var error, result;
        error = arguments[0], result = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        timer.done();
        return _callback.apply(null, [error].concat(__slice.call(result)));
      };
      return OutputFileFinder.findOutputFiles(resources, basePath, function(error, outputFiles, allFiles) {
        var file, jobs, _fn, _i, _len, _ref;
        if (error != null) {
          return callback(error);
        }
        jobs = [];
        _ref = outputFiles || [];
        _fn = function(file) {
          var path, should_delete;
          path = file.path;
          should_delete = true;
          if (path.match(/^output\./) || path.match(/\.aux$/) || path.match(/^cache\//)) {
            should_delete = false;
          }
          if (path.match(/^output-.*/)) {
            should_delete = false;
          }
          if (path.match(/\.(pdf|dpth|md5)$/)) {
            should_delete = false;
          }
          if (path.match(/\.(pygtex|pygstyle)$/) || path.match(/(^|\/)_minted-[^\/]+\//)) {
            should_delete = false;
          }
          if (path.match(/\.md\.tex$/) || path.match(/(^|\/)_markdown_[^\/]+\//)) {
            should_delete = false;
          }
          if (path.match(/-eps-converted-to\.pdf$/)) {
            should_delete = false;
          }
          if (path === "output.pdf" || path === "output.dvi" || path === "output.log" || path === "output.xdv") {
            should_delete = true;
          }
          if (path === "output.tex") {
            should_delete = true;
          }
          if (should_delete) {
            return jobs.push(function(callback) {
              return ResourceWriter._deleteFileIfNotDirectory(Path.join(basePath, path), callback);
            });
          }
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          file = _ref[_i];
          _fn(file);
        }
        return async.series(jobs, function(error) {
          if (error != null) {
            return callback(error);
          }
          return callback(null, outputFiles, allFiles);
        });
      });
    },
    _deleteFileIfNotDirectory: function(path, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return fs.stat(path, function(error, stat) {
        if ((error != null) && error.code === 'ENOENT') {
          return callback();
        } else if (error != null) {
          logger.err({
            err: error,
            path: path
          }, "error stating file in deleteFileIfNotDirectory");
          return callback(error);
        } else if (stat.isFile()) {
          return fs.unlink(path, function(error) {
            if (error != null) {
              logger.err({
                err: error,
                path: path
              }, "error removing file in deleteFileIfNotDirectory");
              return callback(error);
            } else {
              return callback();
            }
          });
        } else {
          return callback();
        }
      });
    },
    _writeResourceToDisk: function(project_id, resource, basePath, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return ResourceWriter.checkPath(basePath, resource.path, function(error, path) {
        if (error != null) {
          return callback(error);
        }
        return mkdirp(Path.dirname(path), function(error) {
          var process, result;
          if (error != null) {
            return callback(error);
          }
          if (resource.url != null) {
            return UrlCache.downloadUrlToFile(project_id, resource.url, path, resource.modified, function(err) {
              if (err != null) {
                logger.err({
                  err: err,
                  project_id: project_id,
                  path: path,
                  resource_url: resource.url,
                  modified: resource.modified
                }, "error downloading file for resources");
              }
              return callback();
            });
          } else {
            process = require("process");
            fs.writeFile(path, resource.content, callback);
            try {
              return result = fs.lstatSync(path);
            } catch (e) {

            }
          }
        });
      });
    },
    checkPath: function(basePath, resourcePath, callback) {
      var path;
      path = Path.normalize(Path.join(basePath, resourcePath));
      if (path.slice(0, basePath.length + 1) !== basePath + "/") {
        return callback(new Error("resource path is outside root directory"));
      } else {
        return callback(null, path);
      }
    }
  };

}).call(this);
