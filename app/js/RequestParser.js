//@ sourceMappingURL=RequestParser.map
// Generated by CoffeeScript 1.6.0
(function() {
  var RequestParser, settings;

  settings = require("settings-sharelatex");

  module.exports = RequestParser = {
    VALID_COMPILERS: ["pdflatex", "latex", "xelatex", "lualatex"],
    MAX_TIMEOUT: 600,
    parse: function(body, callback) {
      var compile, originalRootResourcePath, resource, response, rootResourcePath, sanitizedRootResourcePath, _i, _len, _ref;
      if (callback == null) {
        callback = function(error, data) {};
      }
      response = {};
      if (body.compile == null) {
        return callback("top level object should have a compile attribute");
      }
      compile = body.compile;
      compile.options || (compile.options = {});
      try {
        response.compiler = this._parseAttribute("compiler", compile.options.compiler, {
          validValues: this.VALID_COMPILERS,
          "default": "pdflatex",
          type: "string"
        });
        response.timeout = this._parseAttribute("timeout", compile.options.timeout, {
          "default": RequestParser.MAX_TIMEOUT,
          type: "number"
        });
        response.imageName = this._parseAttribute("imageName", compile.options.imageName, {
          type: "string"
        });
        response.draft = this._parseAttribute("draft", compile.options.draft, {
          "default": false,
          type: "boolean"
        });
        response.check = this._parseAttribute("check", compile.options.check, {
          type: "string"
        });
        response.flags = this._parseAttribute("flags", compile.options.flags, {
          "default": [],
          type: "object"
        });
        response.syncType = this._parseAttribute("syncType", compile.options.syncType, {
          validValues: ["full", "incremental"],
          type: "string"
        });
        response.syncState = this._parseAttribute("syncState", compile.options.syncState, {
          type: "string"
        });
        if (response.timeout > RequestParser.MAX_TIMEOUT) {
          response.timeout = RequestParser.MAX_TIMEOUT;
        }
        response.timeout = response.timeout * 1000;
        response.resources = (function() {
          var _i, _len, _ref, _results;
          _ref = compile.resources || [];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            resource = _ref[_i];
            _results.push(this._parseResource(resource));
          }
          return _results;
        }).call(this);
        rootResourcePath = this._parseAttribute("rootResourcePath", compile.rootResourcePath, {
          "default": "main.tex",
          type: "string"
        });
        originalRootResourcePath = rootResourcePath;
        sanitizedRootResourcePath = RequestParser._sanitizePath(rootResourcePath);
        response.rootResourcePath = RequestParser._checkPath(sanitizedRootResourcePath);
        _ref = response.resources;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          resource = _ref[_i];
          if (resource.path === originalRootResourcePath) {
            resource.path = sanitizedRootResourcePath;
          }
        }
      } catch (error) {
        return callback(error);
      }
      return callback(null, response);
    },
    _parseResource: function(resource) {
      var modified;
      if ((resource.path == null) || typeof resource.path !== "string") {
        throw "all resources should have a path attribute";
      }
      if (resource.modified != null) {
        modified = new Date(resource.modified);
        if (isNaN(modified.getTime())) {
          throw "resource modified date could not be understood: " + resource.modified;
        }
      }
      if ((resource.url == null) && (resource.content == null)) {
        throw "all resources should have either a url or content attribute";
      }
      if ((resource.content != null) && typeof resource.content !== "string") {
        throw "content attribute should be a string";
      }
      if ((resource.url != null) && typeof resource.url !== "string") {
        throw "url attribute should be a string";
      }
      return {
        path: resource.path,
        modified: modified,
        url: resource.url,
        content: resource.content
      };
    },
    _parseAttribute: function(name, attribute, options) {
      if (attribute != null) {
        if (options.validValues != null) {
          if (options.validValues.indexOf(attribute) === -1) {
            throw "" + name + " attribute should be one of: " + (options.validValues.join(", "));
          }
        }
        if (options.type != null) {
          if (typeof attribute !== options.type) {
            throw "" + name + " attribute should be a " + options.type;
          }
        }
      } else {
        if (options["default"] != null) {
          return options["default"];
        }
      }
      return attribute;
    },
    _sanitizePath: function(path) {
      return path.replace(/[\#\&\;\`\|\*\?\~\<\>\^\(\)\[\]\{\}\$\\\x0A\xFF\x00]/g, "");
    },
    _checkPath: function(path) {
      var dir, _i, _len, _ref;
      _ref = path.split('/');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dir = _ref[_i];
        if (dir === '..') {
          throw "relative path in root resource";
        }
      }
      return path;
    }
  };

}).call(this);
