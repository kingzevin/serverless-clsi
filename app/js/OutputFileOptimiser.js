//@ sourceMappingURL=OutputFileOptimiser.map
// Generated by CoffeeScript 1.6.0
(function() {
  var Metrics, OutputFileOptimiser, Path, fs, logger, spawn, _;

  fs = require("fs");

  Path = require("path");

  spawn = require("child_process").spawn;

  logger = require("logger-sharelatex");

  Metrics = require("./Metrics");

  _ = require("underscore");

  module.exports = OutputFileOptimiser = {
    optimiseFile: function(src, dst, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      if (src.match(/\/output\.pdf$/)) {
        return OutputFileOptimiser.checkIfPDFIsOptimised(src, function(err, isOptimised) {
          if ((err != null) || isOptimised) {
            return callback(null);
          }
          return OutputFileOptimiser.optimisePDF(src, dst, callback);
        });
      } else {
        return callback(null);
      }
    },
    checkIfPDFIsOptimised: function(file, callback) {
      var SIZE, result;
      SIZE = 16 * 1024;
      result = new Buffer(SIZE);
      result.fill(0);
      return fs.open(file, "r", function(err, fd) {
        if (err != null) {
          return callback(err);
        }
        return fs.read(fd, result, 0, SIZE, 0, function(errRead, bytesRead, buffer) {
          return fs.close(fd, function(errClose) {
            var isOptimised;
            if (errRead != null) {
              return callback(errRead);
            }
            if (typeof errReadClose !== "undefined" && errReadClose !== null) {
              return callback(errClose);
            }
            isOptimised = buffer.toString('ascii').indexOf("/Linearized 1") >= 0;
            return callback(null, isOptimised);
          });
        });
      });
    },
    optimisePDF: function(src, dst, callback) {
      var args, proc, stdout, timer, tmpOutput;
      if (callback == null) {
        callback = function(error) {};
      }
      tmpOutput = dst + '.opt';
      args = ["--linearize", src, tmpOutput];
      logger.log({
        args: args
      }, "running qpdf command");
      timer = new Metrics.Timer("qpdf");
      proc = spawn("qpdf", args);
      stdout = "";
      proc.stdout.on("data", function(chunk) {
        return stdout += chunk.toString();
      });
      callback = _.once(callback);
      proc.on("error", function(err) {
        logger.warn({
          err: err,
          args: args
        }, "qpdf failed");
        return callback(null);
      });
      return proc.on("close", function(code) {
        timer.done();
        if (code !== 0) {
          logger.warn({
            code: code,
            args: args
          }, "qpdf returned error");
          return callback(null);
        }
        return fs.rename(tmpOutput, dst, function(err) {
          if (err != null) {
            logger.warn({
              tmpOutput: tmpOutput,
              dst: dst
            }, "failed to rename output of qpdf command");
          }
          return callback(null);
        });
      });
    }
  };

}).call(this);
