//@ sourceMappingURL=LocalCommandRunner.map
// Generated by CoffeeScript 1.6.0
(function() {
  var CommandRunner, logger, spawn;

  spawn = require("child_process").spawn;

  logger = require("logger-sharelatex");

  logger.info("using standard command runner");

  module.exports = CommandRunner = {
    run: function(project_id, command, directory, image, timeout, environment, callback) {
      var arg, env, key, proc, stdout, value, _ref;
      if (callback == null) {
        callback = function(error) {};
      }
      command = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = command.length; _i < _len; _i++) {
          arg = command[_i];
          _results.push(arg.toString().replace('$COMPILE_DIR', directory));
        }
        return _results;
      })();
      logger.log({
        project_id: project_id,
        command: command,
        directory: directory
      }, "running command");
      logger.warn("timeouts and sandboxing are not enabled with CommandRunner");
      env = {};
      _ref = process.env;
      for (key in _ref) {
        value = _ref[key];
        env[key] = value;
      }
      for (key in environment) {
        value = environment[key];
        env[key] = value;
      }
      proc = spawn(command[0], command.slice(1), {
        cwd: directory,
        env: env
      });
      stdout = "";
      proc.stdout.on("data", function(data) {
        return stdout += data;
      });
      proc.on("error", function(err) {
        logger.err({
          err: err,
          project_id: project_id,
          command: command,
          directory: directory
        }, "error running command");
        return callback(err);
      });
      proc.on("close", function(code, signal) {
        var err;
        logger.info({
          code: code,
          signal: signal,
          project_id: project_id
        }, "command exited");
        if (signal === 'SIGTERM') {
          err = new Error("terminated");
          err.terminated = true;
          return callback(err);
        } else if (code === 1) {
          err = new Error("exited");
          err.code = code;
          return callback(err);
        } else {
          return callback(null, {
            "stdout": stdout
          });
        }
      });
      return proc.pid;
    },
    kill: function(pid, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      try {
        process.kill(-pid);
      } catch (err) {
        return callback(err);
      }
      return callback();
    }
  };

}).call(this);
