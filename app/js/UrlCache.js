//@ sourceMappingURL=UrlCache.map
// Generated by CoffeeScript 1.6.0
(function() {
  var Settings, UrlCache, UrlFetcher, async, crypto, db, dbQueue, fs, logger;

  db = require("./db");

  dbQueue = require("./DbQueue");

  UrlFetcher = require("./UrlFetcher");

  Settings = require("settings-sharelatex");

  crypto = require("crypto");

  fs = require("fs");

  logger = require("logger-sharelatex");

  async = require("async");

  module.exports = UrlCache = {
    downloadUrlToFile: function(project_id, url, destPath, lastModified, callback) {
      var _this = this;
      if (callback == null) {
        callback = function(error) {};
      }
      return UrlCache._ensureUrlIsInCache(project_id, url, lastModified, function(error, pathToCachedUrl) {
        if (error != null) {
          return callback(error);
        }
        return UrlCache._copyFile(pathToCachedUrl, destPath, function(error) {
          if (error != null) {
            return UrlCache._clearUrlDetails(project_id, url, function() {
              return callback(error);
            });
          } else {
            return callback(error);
          }
        });
      });
    },
    clearProject: function(project_id, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return UrlCache._findAllUrlsInProject(project_id, function(error, urls) {
        var jobs, url;
        logger.log({
          project_id: project_id,
          url_count: urls.length
        }, "clearing project URLs");
        if (error != null) {
          return callback(error);
        }
        jobs = (function() {
          var _i, _len, _ref, _results;
          _ref = urls || [];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            url = _ref[_i];
            _results.push((function(url) {
              return function(callback) {
                return UrlCache._clearUrlFromCache(project_id, url, function(error) {
                  if (error != null) {
                    logger.error({
                      err: error,
                      project_id: project_id,
                      url: url
                    }, "error clearing project URL");
                  }
                  return callback();
                });
              };
            })(url));
          }
          return _results;
        })();
        return async.series(jobs, callback);
      });
    },
    _ensureUrlIsInCache: function(project_id, url, lastModified, callback) {
      var _this = this;
      if (callback == null) {
        callback = function(error, pathOnDisk) {};
      }
      if (lastModified != null) {
        lastModified = new Date(Math.floor(lastModified.getTime() / 1000) * 1000);
      }
      return UrlCache._doesUrlNeedDownloading(project_id, url, lastModified, function(error, needsDownloading) {
        if (error != null) {
          return callback(error);
        }
        if (needsDownloading) {
          logger.log({
            url: url,
            lastModified: lastModified
          }, "downloading URL");
          return UrlFetcher.pipeUrlToFile(url, UrlCache._cacheFilePathForUrl(project_id, url), function(error) {
            if (error != null) {
              return callback(error);
            }
            return UrlCache._updateOrCreateUrlDetails(project_id, url, lastModified, function(error) {
              if (error != null) {
                return callback(error);
              }
              return callback(null, UrlCache._cacheFilePathForUrl(project_id, url));
            });
          });
        } else {
          logger.log({
            url: url,
            lastModified: lastModified
          }, "URL is up to date in cache");
          return callback(null, UrlCache._cacheFilePathForUrl(project_id, url));
        }
      });
    },
    _doesUrlNeedDownloading: function(project_id, url, lastModified, callback) {
      if (callback == null) {
        callback = function(error, needsDownloading) {};
      }
      if (lastModified == null) {
        return callback(null, true);
      }
      return UrlCache._findUrlDetails(project_id, url, function(error, urlDetails) {
        if (error != null) {
          return callback(error);
        }
        if ((urlDetails == null) || (urlDetails.lastModified == null) || urlDetails.lastModified.getTime() < lastModified.getTime()) {
          return callback(null, true);
        } else {
          return callback(null, false);
        }
      });
    },
    _cacheFileNameForUrl: function(project_id, url) {
      return project_id + ":" + crypto.createHash("md5").update(url).digest("hex");
    },
    _cacheFilePathForUrl: function(project_id, url) {
      return "" + Settings.path.clsiCacheDir + "/" + (UrlCache._cacheFileNameForUrl(project_id, url));
    },
    _copyFile: function(from, to, _callback) {
      var callbackOnce, readStream, writeStream;
      if (_callback == null) {
        _callback = function(error) {};
      }
      callbackOnce = function(error) {
        if (error != null) {
          logger.error({
            err: error,
            from: from,
            to: to
          }, "error copying file from cache");
        }
        _callback(error);
        return _callback = function() {};
      };
      writeStream = fs.createWriteStream(to);
      readStream = fs.createReadStream(from);
      writeStream.on("error", callbackOnce);
      readStream.on("error", callbackOnce);
      writeStream.on("close", callbackOnce);
      return writeStream.on("open", function() {
        return readStream.pipe(writeStream);
      });
    },
    _clearUrlFromCache: function(project_id, url, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return UrlCache._clearUrlDetails(project_id, url, function(error) {
        if (error != null) {
          return callback(error);
        }
        return UrlCache._deleteUrlCacheFromDisk(project_id, url, function(error) {
          if (error != null) {
            return callback(error);
          }
          return callback(null);
        });
      });
    },
    _deleteUrlCacheFromDisk: function(project_id, url, callback) {
      if (callback == null) {
        callback = function(error) {};
      }
      return fs.unlink(UrlCache._cacheFilePathForUrl(project_id, url), function(error) {
        if ((error != null) && error.code !== 'ENOENT') {
          return callback(error);
        } else {
          return callback();
        }
      });
    },
    _findUrlDetails: function(project_id, url, callback) {
      var job;
      if (callback == null) {
        callback = function(error, urlDetails) {};
      }
      job = function(cb) {
        return db.UrlCache.find({
          where: {
            url: url,
            project_id: project_id
          }
        }).then(function(urlDetails) {
          return cb(null, urlDetails);
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    },
    _updateOrCreateUrlDetails: function(project_id, url, lastModified, callback) {
      var job;
      if (callback == null) {
        callback = function(error) {};
      }
      job = function(cb) {
        return db.UrlCache.findOrCreate({
          where: {
            url: url,
            project_id: project_id
          }
        }).spread(function(urlDetails, created) {
          return urlDetails.updateAttributes({
            lastModified: lastModified
          }).then(function() {
            return cb();
          }).error(cb);
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    },
    _clearUrlDetails: function(project_id, url, callback) {
      var job;
      if (callback == null) {
        callback = function(error) {};
      }
      job = function(cb) {
        return db.UrlCache.destroy({
          where: {
            url: url,
            project_id: project_id
          }
        }).then(function() {
          return cb(null);
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    },
    _findAllUrlsInProject: function(project_id, callback) {
      var job;
      if (callback == null) {
        callback = function(error, urls) {};
      }
      job = function(cb) {
        return db.UrlCache.findAll({
          where: {
            project_id: project_id
          }
        }).then(function(urlEntries) {
          return cb(null, urlEntries.map(function(entry) {
            return entry.url;
          }));
        }).error(cb);
      };
      return dbQueue.queue.push(job, callback);
    }
  };

}).call(this);
