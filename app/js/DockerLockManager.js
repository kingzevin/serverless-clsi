//@ sourceMappingURL=DockerLockManager.map
// Generated by CoffeeScript 1.6.0
(function() {
  var LockManager, LockState, logger,
    __slice = [].slice;

  logger = require("logger-sharelatex");

  LockState = {};

  module.exports = LockManager = {
    MAX_LOCK_HOLD_TIME: 15000,
    MAX_LOCK_WAIT_TIME: 10000,
    LOCK_TEST_INTERVAL: 1000,
    tryLock: function(key, callback) {
      var existingLock, lockAge, lockValue;
      if (callback == null) {
        callback = function(err, gotLock) {};
      }
      existingLock = LockState[key];
      if (existingLock != null) {
        lockAge = Date.now() - existingLock.created;
        if (lockAge < LockManager.MAX_LOCK_HOLD_TIME) {
          return callback(null, false);
        } else {
          logger.error({
            key: key,
            lock: existingLock,
            age: lockAge
          }, "taking old lock by force");
        }
      }
      LockState[key] = lockValue = {
        created: Date.now()
      };
      return callback(null, true, lockValue);
    },
    getLock: function(key, callback) {
      var attempt, startTime;
      if (callback == null) {
        callback = function(error, lockValue) {};
      }
      startTime = Date.now();
      return (attempt = function() {
        return LockManager.tryLock(key, function(error, gotLock, lockValue) {
          var e;
          if (error != null) {
            return callback(error);
          }
          if (gotLock) {
            return callback(null, lockValue);
          } else if (Date.now() - startTime > LockManager.MAX_LOCK_WAIT_TIME) {
            e = new Error("Lock timeout");
            e.key = key;
            return callback(e);
          } else {
            return setTimeout(attempt, LockManager.LOCK_TEST_INTERVAL);
          }
        });
      })();
    },
    releaseLock: function(key, lockValue, callback) {
      var existingLock;
      if (callback == null) {
        callback = function(error) {};
      }
      existingLock = LockState[key];
      if (existingLock === lockValue) {
        delete LockState[key];
        return callback();
      } else if (existingLock != null) {
        logger.error({
          key: key,
          lock: existingLock
        }, "tried to release lock taken by force");
        return callback();
      } else {
        logger.error({
          key: key,
          lock: existingLock
        }, "tried to release lock that has gone");
        return callback();
      }
    },
    runWithLock: function(key, runner, callback) {
      if (runner == null) {
        runner = (function(releaseLock) {
          if (releaseLock == null) {
            releaseLock = function(error) {};
          }
        });
      }
      if (callback == null) {
        callback = (function(error) {});
      }
      return LockManager.getLock(key, function(error, lockValue) {
        if (error != null) {
          return callback(error);
        }
        return runner(function() {
          var args, error1;
          error1 = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
          return LockManager.releaseLock(key, lockValue, function(error2) {
            error = error1 || error2;
            if (error != null) {
              return callback(error);
            }
            return callback.apply(null, [null].concat(__slice.call(args)));
          });
        });
      });
    }
  };

}).call(this);
