//@ sourceMappingURL=CompileController.map
// Generated by CoffeeScript 1.6.0
(function() {
  var CompileController, CompileManager, Errors, Metrics, ProjectPersistenceManager, RequestParser, Settings, logger;

  RequestParser = require("./RequestParser");

  CompileManager = require("./CompileManager");

  Settings = require("settings-sharelatex");

  Metrics = require("./Metrics");

  ProjectPersistenceManager = require("./ProjectPersistenceManager");

  logger = require("logger-sharelatex");

  Errors = require("./Errors");

  module.exports = CompileController = {
    compile: function(req, res, next) {
      var timer;
      if (next == null) {
        next = function(error) {};
      }
      timer = new Metrics.Timer("compile-request");
      return RequestParser.parse(req.body, function(error, request) {
        if (error != null) {
          return next(error);
        }
        request.project_id = req.params.project_id;
        if (req.params.user_id != null) {
          request.user_id = req.params.user_id;
        }
        return ProjectPersistenceManager.markProjectAsJustAccessed(request.project_id, function(error) {
          if (error != null) {
            return next(error);
          }
          return CompileManager.doCompileWithLock(request, function(error, outputFiles) {
            var code, file, status, _i, _j, _len, _len1, _ref;
            if (outputFiles == null) {
              outputFiles = [];
            }
            if (error instanceof Errors.AlreadyCompilingError) {
              code = 423;
              status = "compile-in-progress";
            } else if (error instanceof Errors.FilesOutOfSyncError) {
              code = 409;
              status = "retry";
            } else if (error != null ? error.terminated : void 0) {
              status = "terminated";
            } else if (error != null ? error.validate : void 0) {
              status = "validation-" + error.validate;
            } else if (error != null ? error.timedout : void 0) {
              status = "timedout";
              logger.log({
                err: error,
                project_id: request.project_id
              }, "timeout running compile");
            } else if (error != null) {
              status = "error";
              code = 500;
              logger.warn({
                err: error,
                project_id: request.project_id
              }, "error running compile");
            } else {
              status = "failure";
              for (_i = 0, _len = outputFiles.length; _i < _len; _i++) {
                file = outputFiles[_i];
                if ((_ref = file.path) != null ? _ref.match(/output\.pdf$/) : void 0) {
                  status = "success";
                }
              }
              if (status === "failure") {
                logger.warn({
                  project_id: request.project_id,
                  outputFiles: outputFiles
                }, "project failed to compile successfully, no output.pdf generated");
              }
              for (_j = 0, _len1 = outputFiles.length; _j < _len1; _j++) {
                file = outputFiles[_j];
                if (file.path === "core") {
                  logger.error({
                    project_id: request.project_id,
                    req: req,
                    outputFiles: outputFiles
                  }, "core file found in output");
                }
              }
            }
            if (error != null) {
              outputFiles = error.outputFiles || [];
            }
            timer.done();
            return res.status(code || 200).send({
              compile: {
                status: status,
                error: (error != null ? error.message : void 0) || error,
                outputFiles: outputFiles.map(function(file) {
                  const filestoreUrl = `http://${Settings.apis.filestore.url.host}:${Settings.apis.filestore.url.port}`;
                  // const filestoreUrl = Settings.apis.filestore? `http://${Settings.apis.filestore.url.host}:${Settings.apis.filestore.url.port}` : 'http://172.17.0.1:3009';

                  return {
                    url: ("" + filestoreUrl + "/project/" + request.project_id) + ("/file/output_" + file.build + "_" + file.path),
                    path: file.path,
                    type: file.type,
                    build: file.build
                  };
                })
              }
            });
          });
        });
      });
    },
    stopCompile: function(req, res, next) {
      var project_id, user_id, _ref;
      _ref = req.params, project_id = _ref.project_id, user_id = _ref.user_id;
      return CompileManager.stopCompile(project_id, user_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.sendStatus(204);
      });
    },
    clearCache: function(req, res, next) {
      if (next == null) {
        next = function(error) {};
      }
      return ProjectPersistenceManager.clearProject(req.params.project_id, req.params.user_id, function(error) {
        if (error != null) {
          return next(error);
        }
        return res.sendStatus(204);
      });
    },
    syncFromCode: function(req, res, next) {
      var column, file, line, project_id, user_id;
      if (next == null) {
        next = function(error) {};
      }
      file = req.query.file;
      line = parseInt(req.query.line, 10);
      column = parseInt(req.query.column, 10);
      project_id = req.params.project_id;
      user_id = req.params.user_id;
      return CompileManager.syncFromCode(project_id, user_id, file, line, column, function(error, pdfPositions) {
        if (error != null) {
          return next(error);
        }
        return res.json({
          pdf: pdfPositions
        });
      });
    },
    syncFromPdf: function(req, res, next) {
      var h, page, project_id, user_id, v;
      if (next == null) {
        next = function(error) {};
      }
      page = parseInt(req.query.page, 10);
      h = parseFloat(req.query.h);
      v = parseFloat(req.query.v);
      project_id = req.params.project_id;
      user_id = req.params.user_id;
      return CompileManager.syncFromPdf(project_id, user_id, page, h, v, function(error, codePositions) {
        if (error != null) {
          return next(error);
        }
        return res.json({
          code: codePositions
        });
      });
    },
    wordcount: function(req, res, next) {
      var file, image, project_id, user_id;
      if (next == null) {
        next = function(error) {};
      }
      file = req.query.file || "main.tex";
      project_id = req.params.project_id;
      user_id = req.params.user_id;
      image = req.query.image;
      logger.log({
        image: image,
        file: file,
        project_id: project_id
      }, "word count request");
      return CompileManager.wordcount(project_id, user_id, file, image, function(error, result) {
        if (error != null) {
          return next(error);
        }
        return res.json({
          texcount: result
        });
      });
    },
    status: function(req, res, next) {
      if (next == null) {
        next = function(error) {};
      }
      return res.send("OK");
    }
  };

}).call(this);
