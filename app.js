//@ sourceMappingURL=app.map
// Generated by CoffeeScript 1.6.0
(function() {
  var CompileController, ContentTypeMapper, Errors, ForbidSymlinks, Metrics, OutputCacheManager, Path, ProjectPersistenceManager, STATE, Settings, TIMEOUT, app, bodyParser, express, fs, host, loadHttpServer, loadTcpServer, load_http_port, load_tcp_port, logger, net, os, port, profiler, resCacher, runSmokeTest, smokeTest, staticServer, tenMinutes, _ref, _ref1, _ref2, _ref3, _ref4;

  Metrics = require("metrics-sharelatex");

  Metrics.initialize("clsi");

  CompileController = require("./app/js/CompileController");

  Settings = require("settings-sharelatex");

  logger = require("logger-sharelatex");

  logger.initialize("clsi");

  if (((_ref = Settings.sentry) != null ? _ref.dsn : void 0) != null) {
    logger.initializeErrorReporting(Settings.sentry.dsn);
  }

  smokeTest = require("smoke-test-sharelatex");

  ContentTypeMapper = require("./app/js/ContentTypeMapper");

  Errors = require('./app/js/Errors');

  Path = require("path");

  fs = require("fs");

  Metrics.open_sockets.monitor(logger);

  Metrics.memory.monitor(logger);

  ProjectPersistenceManager = require("./app/js/ProjectPersistenceManager");

  OutputCacheManager = require("./app/js/OutputCacheManager");

  require("./app/js/db").sync();

  express = require("express");

  bodyParser = require("body-parser");

  app = express();

  Metrics.injectMetricsRoute(app);

  app.use(Metrics.http.monitor(logger));

  TIMEOUT = 10 * 60 * 1000;

  app.use(function(req, res, next) {
    req.setTimeout(TIMEOUT);
    res.setTimeout(TIMEOUT);
    res.removeHeader("X-Powered-By");
    return next();
  });

  app.param('project_id', function(req, res, next, project_id) {
    if (project_id != null ? project_id.match(/^[a-zA-Z0-9_-]+$/) : void 0) {
      return next();
    } else {
      return next(new Error("invalid project id"));
    }
  });

  app.param('user_id', function(req, res, next, user_id) {
    if (user_id != null ? user_id.match(/^[0-9a-f]{24}$/) : void 0) {
      return next();
    } else {
      return next(new Error("invalid user id"));
    }
  });

  app.param('build_id', function(req, res, next, build_id) {
    if (build_id != null ? build_id.match(OutputCacheManager.BUILD_REGEX) : void 0) {
      return next();
    } else {
      return next(new Error("invalid build id " + build_id));
    }
  });

  app.post("/project/:project_id/compile", bodyParser.json({
    limit: Settings.compileSizeLimit
  }), CompileController.compile);

  app.post("/project/:project_id/compile/stop", CompileController.stopCompile);

  app["delete"]("/project/:project_id", CompileController.clearCache);

  app.get("/project/:project_id/sync/code", CompileController.syncFromCode);

  app.get("/project/:project_id/sync/pdf", CompileController.syncFromPdf);

  app.get("/project/:project_id/wordcount", CompileController.wordcount);

  app.get("/project/:project_id/status", CompileController.status);

  app.post("/project/:project_id/user/:user_id/compile", bodyParser.json({
    limit: Settings.compileSizeLimit
  }), CompileController.compile);

  app.post("/project/:project_id/user/:user_id/compile/stop", CompileController.stopCompile);

  app["delete"]("/project/:project_id/user/:user_id", CompileController.clearCache);

  app.get("/project/:project_id/user/:user_id/sync/code", CompileController.syncFromCode);

  app.get("/project/:project_id/user/:user_id/sync/pdf", CompileController.syncFromPdf);

  app.get("/project/:project_id/user/:user_id/wordcount", CompileController.wordcount);

  ForbidSymlinks = require("./app/js/StaticServerForbidSymlinks");

  staticServer = ForbidSymlinks(express["static"], Settings.path.compilesDir, {
    setHeaders: function(res, path, stat) {
      var etag;
      if (Path.basename(path) === "output.pdf") {
        etag = function(path, stat) {
          return '"' + Math.ceil(+stat.mtime / 1000).toString(16) + '-' + Number(stat.size).toString(16) + '"';
        };
        res.set("Etag", etag(path, stat));
      }
      return res.set("Content-Type", ContentTypeMapper.map(path));
    }
  });

  app.get("/project/:project_id/user/:user_id/build/:build_id/output/*", function(req, res, next) {
    req.url = ("/" + req.params.project_id + "-" + req.params.user_id + "/") + OutputCacheManager.path(req.params.build_id, "/" + req.params[0]);
    return staticServer(req, res, next);
  });

  app.get("/project/:project_id/build/:build_id/output/*", function(req, res, next) {
    req.url = ("/" + req.params.project_id + "/") + OutputCacheManager.path(req.params.build_id, "/" + req.params[0]);
    return staticServer(req, res, next);
  });

  app.get("/project/:project_id/user/:user_id/output/*", function(req, res, next) {
    req.url = "/" + req.params.project_id + "-" + req.params.user_id + "/" + req.params[0];
    return staticServer(req, res, next);
  });

  app.get("/project/:project_id/output/*", function(req, res, next) {
    var _ref1;
    if ((((_ref1 = req.query) != null ? _ref1.build : void 0) != null) && req.query.build.match(OutputCacheManager.BUILD_REGEX)) {
      req.url = ("/" + req.params.project_id + "/") + OutputCacheManager.path(req.query.build, "/" + req.params[0]);
    } else {
      req.url = "/" + req.params.project_id + "/" + req.params[0];
    }
    return staticServer(req, res, next);
  });

  app.get("/oops", function(req, res, next) {
    logger.error({
      err: "hello"
    }, "test error");
    return res.send("error\n");
  });

  app.get("/status", function(req, res, next) {
    return res.send("CLSI is alive\n");
  });

  resCacher = {
    contentType: function(setContentType) {
      this.setContentType = setContentType;
    },
    send: function(code, body) {
      this.code = code;
      this.body = body;
    },
    code: 500,
    body: {},
    setContentType: "application/json"
  };

  if (Settings.smokeTest) {
    (runSmokeTest = function() {
      logger.log("running smoke tests");
      smokeTest.run(require.resolve(__dirname + "/test/smoke/js/SmokeTests.js"))({}, resCacher);
      return setTimeout(runSmokeTest, 30 * 1000);
    })();
  }

  app.get("/health_check", function(req, res) {
    res.contentType(resCacher != null ? resCacher.setContentType : void 0);
    return res.status(resCacher != null ? resCacher.code : void 0).send(resCacher != null ? resCacher.body : void 0);
  });

  app.get("/smoke_test_force", function(req, res) {
    return smokeTest.run(require.resolve(__dirname + "/test/smoke/js/SmokeTests.js"))(req, res);
  });

  profiler = require("v8-profiler-node8");

  app.get("/profile", function(req, res) {
    var time;
    time = parseInt(req.query.time || "1000");
    profiler.startProfiling("test");
    return setTimeout(function() {
      var profile;
      profile = profiler.stopProfiling("test");
      return res.json(profile);
    }, time);
  });

  app.get("/heapdump", function(req, res) {
    return require('heapdump').writeSnapshot('/tmp/' + Date.now() + '.clsi.heapsnapshot', function(err, filename) {
      return res.send(filename);
    });
  });

  app.use(function(error, req, res, next) {
    if (error instanceof Errors.NotFoundError) {
      logger.warn({
        err: error,
        url: req.url
      }, "not found error");
      return res.sendStatus(404);
    } else {
      logger.error({
        err: error,
        url: req.url
      }, "server error");
      return res.sendStatus((error != null ? error.statusCode : void 0) || 500);
    }
  });

  net = require("net");

  os = require("os");

  STATE = "up";

  loadTcpServer = net.createServer(function(socket) {
    var availableWorkingCpus, currentLoad, freeLoad, freeLoadPercentage;
    socket.on("error", function(err) {
      if (err.code === "ECONNRESET") {
        return;
      }
      logger.err({
        err: err
      }, "error with socket on load check");
      return socket.destroy();
    });
    if (STATE === "up" && Settings.internal.load_balancer_agent.report_load) {
      currentLoad = os.loadavg()[0];
      if (os.cpus().length === 1) {
        availableWorkingCpus = 1;
      } else {
        availableWorkingCpus = os.cpus().length - 1;
      }
      freeLoad = availableWorkingCpus - currentLoad;
      freeLoadPercentage = Math.round((freeLoad / availableWorkingCpus) * 100);
      if (freeLoadPercentage <= 0) {
        freeLoadPercentage = 1;
      }
      socket.write("up, " + freeLoadPercentage + "%\n", "ASCII");
      return socket.end();
    } else {
      socket.write("" + STATE + "\n", "ASCII");
      return socket.end();
    }
  });

  loadHttpServer = express();

  loadHttpServer.post("/state/up", function(req, res, next) {
    STATE = "up";
    logger.info("getting message to set server to down");
    return res.sendStatus(204);
  });

  loadHttpServer.post("/state/down", function(req, res, next) {
    STATE = "down";
    logger.info("getting message to set server to down");
    return res.sendStatus(204);
  });

  loadHttpServer.post("/state/maint", function(req, res, next) {
    STATE = "maint";
    logger.info("getting message to set server to maint");
    return res.sendStatus(204);
  });

  port = ((_ref1 = Settings.internal) != null ? (_ref2 = _ref1.clsi) != null ? _ref2.port : void 0 : void 0) || 3013;

  host = ((_ref3 = Settings.internal) != null ? (_ref4 = _ref3.clsi) != null ? _ref4.host : void 0 : void 0) || "localhost";

  load_tcp_port = Settings.internal.load_balancer_agent.load_port;

  load_http_port = Settings.internal.load_balancer_agent.local_port;

  if (!module.parent) {
    app.listen(port, host, function(error) {
      return logger.info("CLSI starting up, listening on " + host + ":" + port);
    });
    loadTcpServer.listen(load_tcp_port, host, function(error) {
      if (error != null) {
        throw error;
      }
      return logger.info("Load tcp agent listening on load port " + load_tcp_port);
    });
    loadHttpServer.listen(load_http_port, host, function(error) {
      if (error != null) {
        throw error;
      }
      return logger.info("Load http agent listening on load port " + load_http_port);
    });
  }
  module.exports = app; // clsi.express.exports

  setInterval(function() {
    return ProjectPersistenceManager.clearExpiredProjects();
  }, tenMinutes = 10 * 60 * 1000);

}).call(this);
